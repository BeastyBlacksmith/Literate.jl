<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>3. Processing pipeline · Literate.jl</title><link href="https://fredrikekre.github.io/Literate.jl/v2/pipeline/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="Literate.jl logo" src="../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">Literate.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../fileformat/"><strong>2.</strong> File Format</a></li><li class="is-active"><a class="tocitem" href=""><strong>3.</strong> Processing pipeline</a><ul class="internal"><li><a class="tocitem" href="#Pre-processing"><span><strong>3.1.</strong> Pre-processing</span></a></li><li><a class="tocitem" href="#Parsing"><span><strong>3.2.</strong> Parsing</span></a></li><li><a class="tocitem" href="#Document-generation"><span><strong>3.3.</strong> Document generation</span></a></li><li><a class="tocitem" href="#Post-processing"><span><strong>3.4.</strong> Post-processing</span></a></li><li><a class="tocitem" href="#Writing-to-file"><span><strong>3.5.</strong> Writing to file</span></a></li></ul></li><li><a class="tocitem" href="../outputformats/"><strong>4.</strong> Output Formats</a></li><li><a class="tocitem" href="../customprocessing/"><strong>5.</strong> Custom pre- and post-processing</a></li><li><a class="tocitem" href="../documenter/"><strong>6.</strong> Interaction with Documenter.jl</a></li><li><a class="tocitem" href="../tips/"><strong>7.</strong> Tips and Tricks</a></li><li><a class="tocitem" href="../generated/example/"><strong>8.</strong> Example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href=""><strong>3.</strong> Processing pipeline</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href=""><strong>3.</strong> Processing pipeline</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fredrikekre/Literate.jl/blob/master/docs/src/pipeline.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Processing-pipeline"><a class="docs-heading-anchor" href="#Processing-pipeline"><strong>3.</strong> Processing pipeline</a><a id="Processing-pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-pipeline" title="Permalink"></a></h1><p>The generation of output follows the same pipeline for all output formats:</p><ol><li><a href="#Pre-processing">Pre-processing</a></li><li><a href="#Parsing">Parsing</a></li><li><a href="#Document-generation">Document generation</a></li><li><a href="#Post-processing">Post-processing</a></li><li><a href="#Writing-to-file">Writing to file</a></li></ol><h2 id="Pre-processing"><a class="docs-heading-anchor" href="#Pre-processing"><strong>3.1.</strong> Pre-processing</a><a id="Pre-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-processing" title="Permalink"></a></h2><p>The first step is pre-processing of the input file. The file is read to a <code>String</code>. The first processing step is to apply the user specified pre-processing function, see <a href="../customprocessing/#Custom-pre-and-post-processing">Custom pre- and post-processing</a>.</p><p>The next step is to perform all of the built-in default replacements. CRLF style line endings (<code>"\r\n"</code>) are replaced with LF line endings (<code>"\n"</code>) to simplify internal processing. Next, line filtering is performed, see <a href="../fileformat/#Filtering-Lines">Filtering Lines</a>, meaning that lines starting with <code>#md</code>, <code>#nb</code> or <code>#jl</code> are handled (either just the token itself is removed, or the full line, depending on the output target). The last pre-processing step is to expand the convenience "macros" described in <a href="../fileformat/#Default-Replacements">Default Replacements</a> is expanded.</p><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing"><strong>3.2.</strong> Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><p>After the preprocessing the file is parsed. The first step is to categorize each line and mark them as either markdown or code according to the rules described in the <a href="../fileformat/#Syntax">Syntax</a> section. Lets consider the example from the previous section with each line categorized:</p><pre><code class="language-none"># # Rational numbers                                                     &lt;- markdown
#                                                                        &lt;- markdown
# In julia rational numbers can be constructed with the `//` operator.   &lt;- markdown
# Lets define two rational numbers, `x` and `y`:                         &lt;- markdown
                                                                         &lt;- code
## Define variable x and y                                               &lt;- code
x = 1 // 3                                                               &lt;- code
y = 2 // 5                                                               &lt;- code
                                                                         &lt;- code
# When adding `x` and `y` together we obtain a new rational number:      &lt;- markdown
                                                                         &lt;- code
z = x + y                                                                &lt;- code</code></pre><p>In the next step the lines are grouped into "chunks" of markdown and code. This is done by simply collecting adjacent lines of the same "type" into chunks:</p><pre><code class="language-none"># # Rational numbers                                                     ┐
#                                                                        │
# In julia rational numbers can be constructed with the `//` operator.   │ markdown
# Lets define two rational numbers, `x` and `y`:                         ┘
                                                                         ┐
## Define variable x and y                                               │
x = 1 // 3                                                               │
y = 2 // 5                                                               │ code
                                                                         ┘
# When adding `x` and `y` together we obtain a new rational number:      ] markdown
                                                                         ┐
z = x + y                                                                ┘ code</code></pre><p>In the last parsing step all empty leading and trailing lines for each chunk are removed, but empty lines <em>within the same</em> block are kept. The leading <code>#</code> tokens are also removed from the markdown chunks. Finally we would end up with the following 4 chunks:</p><p>Chunks #1:</p><pre><code class="language-markdown"># Rational numbers

In julia rational numbers can be constructed with the `//` operator.
Lets define two rational numbers, `x` and `y`:</code></pre><p>Chunk #2:</p><pre><code class="language-julia"># Define variable x and y
x = 1 // 3
y = 2 // 5</code></pre><p>Chunk #3:</p><pre><code class="language-markdown">When adding `x` and `y` together we obtain a new rational number:</code></pre><p>Chunk #4:</p><pre><code class="language-julia">z = x + y</code></pre><p>It is then up to the <a href="#Document-generation">Document generation</a> step to decide how these chunks should be treated.</p><h3 id="Custom-control-over-chunk-splits"><a class="docs-heading-anchor" href="#Custom-control-over-chunk-splits">Custom control over chunk splits</a><a id="Custom-control-over-chunk-splits-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-control-over-chunk-splits" title="Permalink"></a></h3><p>Sometimes it is convenient to be able to manually control how the chunks are split. For example, if you want to split a block of code into two, such that they end up in two different <code>@example</code> blocks or notebook cells. The <code>#-</code> token can be used for this purpose. All lines starting with <code>#-</code> are used as "chunk-splitters":</p><pre><code class="language-julia">x = 1 // 3
y = 2 // 5
#-
z = x + y</code></pre><p>The example above would result in two consecutive code-chunks.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The rest of the line, after <code>#-</code>, is discarded, so it is possible to use e.g. <code>#-------------</code> as a chunk splitter, which may make the source code more readable.</p></div></div><p>It is also possible to use <code>#+</code> as a chunk splitter. The difference between <code>#+</code> and <code>#-</code> is that <code>#+</code> enables Documenter's "continued"-blocks, see the <a href="https://juliadocs.github.io/Documenter.jl/stable/">Documenter manual</a>.</p><h2 id="Document-generation"><a class="docs-heading-anchor" href="#Document-generation"><strong>3.3.</strong> Document generation</a><a id="Document-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Document-generation" title="Permalink"></a></h2><p>After the parsing it is time to generate the output. What is done in this step is very different depending on the output target, and it is described in more detail in the Output format sections: <a href="../outputformats/#Markdown-Output">Markdown Output</a>, <a href="../outputformats/#Notebook-Output">Notebook Output</a> and <a href="../outputformats/#Script-Output">Script Output</a>. Using the default settings, the following is happening:</p><ul><li>Markdown output: markdown chunks are printed as-is, code chunks are put inside a code fence (defaults to <code>@example</code>-blocks),</li><li>Notebook output: markdown chunks are printed in markdown cells, code chunks are put in code cells,</li><li>Script output: markdown chunks are discarded, code chunks are printed as-is.</li></ul><h2 id="Post-processing"><a class="docs-heading-anchor" href="#Post-processing"><strong>3.4.</strong> Post-processing</a><a id="Post-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing" title="Permalink"></a></h2><p>When the document is generated the user, again, has the option to hook-into the generation with a custom post-processing function. The reason is that one might want to change things that are only visible in the rendered document. See <a href="../customprocessing/#Custom-pre-and-post-processing">Custom pre- and post-processing</a>.</p><h2 id="Writing-to-file"><a class="docs-heading-anchor" href="#Writing-to-file"><strong>3.5.</strong> Writing to file</a><a id="Writing-to-file-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-to-file" title="Permalink"></a></h2><p>The last step of the generation is writing to file. The result is written to <code>$(outputdir)/$(name)(.md|.ipynb|.jl)</code> where <code>outputdir</code> is the output directory supplied by the user (for example <code>docs/generated</code>), and <code>name</code> is a user supplied filename. It is recommended to add the output directory to <code>.gitignore</code> since the idea is that the generated documents will be generated as part of the build process rather than beeing files in the repo.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fileformat/">« <strong>2.</strong> File Format</a><a class="docs-footer-nextpage" href="../outputformats/"><strong>4.</strong> Output Formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 3 August 2020 22:25">Monday 3 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>